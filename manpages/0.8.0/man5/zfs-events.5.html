<HTML><HEAD><TITLE>Manpage of ZFS-EVENTS</TITLE>
</HEAD><BODY>
<H1>ZFS-EVENTS</H1>
Section: File Formats (5)<BR>Updated: Oct 24, 2018<BR>
<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAD">EVENTS (SUBCLASS)</A><DD>
<DT><A HREF="#lbAE">PAYLOADS</A><DD>
<DT><A HREF="#lbAF">I/O STAGES</A><DD>
<DT><A HREF="#lbAG">I/O FLAGS</A><DD>
</DL>
</DL>
<HR>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

zfs-events - Events created by the ZFS filesystem.
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>
<P>

Description of the different events generated by the ZFS stack.
<P>
Most of these don't have any description. The events generated by ZFS
have never been publicly documented.  What is here is intended as a
starting point to provide documentation for all possible events.
<P>
To view all events created since the loading of the ZFS infrastructure
(i.e, &quot;the module&quot;), run

<PRE>
<B>zpool events</B>
</PRE>


to get a short list, and

<PRE>
<B>zpool events -v</B>
</PRE>


to get a full detail of the events and what information
is available about it.
<P>
This man page lists the different subclasses that are issued
in the case of an event. The full event name would be
<I>ereport.fs.zfs.SUBCLASS</I>, but we only list the last
part here.
<P>
<A NAME="lbAD">&nbsp;</A>
<H3>EVENTS (SUBCLASS)</H3>

<P>
<P>

<P>
<P>


<B>checksum</B>

<DL COMPACT><DT><DD>
Issued when a checksum error has been detected.
</DL>

<P>
<P>


<B>io</B>

<DL COMPACT><DT><DD>
Issued when there is an I/O error in a vdev in the pool.
</DL>

<P>
<P>


<B>data</B>

<DL COMPACT><DT><DD>
Issued when there have been data errors in the pool.
</DL>

<P>
<P>


<B>deadman</B>

<DL COMPACT><DT><DD>
Issued when an I/O is determined to be &quot;hung&quot;, this can be caused by lost
completion events due to flaky hardware or drivers.  See the
<B>zfs_deadman_failmode</B> module option description for additional
information regarding &quot;hung&quot; I/O detection and configuration.
</DL>

<P>
<P>


<B>delay</B>

<DL COMPACT><DT><DD>
Issued when a completed I/O exceeds the maximum allowed time specified
by the <B>zio_slow_io_ms</B> module option.  This can be an indicator of
problems with the underlying storage device.  The number of delay events is
ratelimited by the <B>zfs_slow_io_events_per_second</B> module parameter.
</DL>

<P>
<P>


<B>config.sync</B>

<DL COMPACT><DT><DD>
Issued every time a vdev change have been done to the pool.
</DL>

<P>
<P>


<B>zpool</B>

<DL COMPACT><DT><DD>
Issued when a pool cannot be imported.
</DL>

<P>
<P>


<B>zpool.destroy</B>

<DL COMPACT><DT><DD>
Issued when a pool is destroyed.
</DL>

<P>
<P>


<B>zpool.export</B>

<DL COMPACT><DT><DD>
Issued when a pool is exported.
</DL>

<P>
<P>


<B>zpool.import</B>

<DL COMPACT><DT><DD>
Issued when a pool is imported.
</DL>

<P>
<P>


<B>zpool.reguid</B>

<DL COMPACT><DT><DD>
Issued when a REGUID (new unique identifier for the pool have been regenerated) have been detected.
</DL>

<P>
<P>


<B>vdev.unknown</B>

<DL COMPACT><DT><DD>
Issued when the vdev is unknown. Such as trying to clear device
errors on a vdev that have failed/been kicked from the system/pool
and is no longer available.
</DL>

<P>
<P>


<B>vdev.open_failed</B>

<DL COMPACT><DT><DD>
Issued when a vdev could not be opened (because it didn't exist for example).
</DL>

<P>
<P>


<B>vdev.corrupt_data</B>

<DL COMPACT><DT><DD>
Issued when corrupt data have been detected on a vdev.
</DL>

<P>
<P>


<B>vdev.no_replicas</B>

<DL COMPACT><DT><DD>
Issued when there are no more replicas to sustain the pool.
This would lead to the pool being <I>DEGRADED</I>.
</DL>

<P>
<P>


<B>vdev.bad_guid_sum</B>

<DL COMPACT><DT><DD>
Issued when a missing device in the pool have been detected.
</DL>

<P>
<P>


<B>vdev.too_small</B>

<DL COMPACT><DT><DD>
Issued when the system (kernel) have removed a device, and ZFS
notices that the device isn't there any more. This is usually
followed by a <B>probe_failure</B> event.
</DL>

<P>
<P>


<B>vdev.bad_label</B>

<DL COMPACT><DT><DD>
Issued when the label is OK but invalid.
</DL>

<P>
<P>


<B>vdev.bad_ashift</B>

<DL COMPACT><DT><DD>
Issued when the ashift alignment requirement has increased.
</DL>

<P>
<P>


<B>vdev.remove</B>

<DL COMPACT><DT><DD>
Issued when a vdev is detached from a mirror (or a spare detached from a
vdev where it have been used to replace a failed drive - only works if
the original drive have been readded).
</DL>

<P>
<P>


<B>vdev.clear</B>

<DL COMPACT><DT><DD>
Issued when clearing device errors in a pool. Such as running <B>zpool clear</B>
on a device in the pool.
</DL>

<P>
<P>


<B>vdev.check</B>

<DL COMPACT><DT><DD>
Issued when a check to see if a given vdev could be opened is started.
</DL>

<P>
<P>


<B>vdev.spare</B>

<DL COMPACT><DT><DD>
Issued when a spare have kicked in to replace a failed device.
</DL>

<P>
<P>


<B>vdev.autoexpand</B>

<DL COMPACT><DT><DD>
Issued when a vdev can be automatically expanded.
</DL>

<P>
<P>


<B>io_failure</B>

<DL COMPACT><DT><DD>
Issued when there is an I/O failure in a vdev in the pool.
</DL>

<P>
<P>


<B>probe_failure</B>

<DL COMPACT><DT><DD>
Issued when a probe fails on a vdev. This would occur if a vdev
have been kicked from the system outside of ZFS (such as the kernel
have removed the device).
</DL>

<P>
<P>


<B>log_replay</B>

<DL COMPACT><DT><DD>
Issued when the intent log cannot be replayed.  The can occur in the case
of a missing or damaged log device.
</DL>

<P>
<P>


<B>resilver.start</B>

<DL COMPACT><DT><DD>
Issued when a resilver is started.
</DL>

<P>
<P>


<B>resilver.finish</B>

<DL COMPACT><DT><DD>
Issued when the running resilver have finished.
</DL>

<P>
<P>


<B>scrub.start</B>

<DL COMPACT><DT><DD>
Issued when a scrub is started on a pool.
</DL>

<P>
<P>


<B>scrub.finish</B>

<DL COMPACT><DT><DD>
Issued when a pool has finished scrubbing.
</DL>

<P>
<P>


<B>scrub.abort</B>

<DL COMPACT><DT><DD>
Issued when a scrub is aborted on a pool.
</DL>

<P>
<P>


<B>scrub.resume</B>

<DL COMPACT><DT><DD>
Issued when a scrub is resumed on a pool.
</DL>

<P>
<P>


<B>scrub.paused</B>

<DL COMPACT><DT><DD>
Issued when a scrub is paused on a pool.
</DL>

<P>
<P>


<B>bootfs.vdev.attach</B>

<DL COMPACT><DT><DD>
</DL>

<P>
<A NAME="lbAE">&nbsp;</A>
<H3>PAYLOADS</H3>

<P>
<P>

This is the payload (data, information) that accompanies an
event.
<P>
For
<B><A HREF="../man8/zed.8.html">zed</A></B>(8),

these are set to uppercase and prefixed with <B>ZEVENT_</B>.
<P>
<P>


<B>pool</B>

<DL COMPACT><DT><DD>
Pool name.
</DL>

<P>
<P>


<B>pool_failmode</B>

<DL COMPACT><DT><DD>
Failmode - <B>wait</B>, <B>continue</B> or <B>panic</B>.
See
<B><A HREF="../man8/zpool.8.html">zpool</A></B>(8)

(<I>failmode</I> property) for more information.
</DL>

<P>
<P>


<B>pool_guid</B>

<DL COMPACT><DT><DD>
The GUID of the pool.
</DL>

<P>
<P>


<B>pool_context</B>

<DL COMPACT><DT><DD>
The load state for the pool (0=none, 1=open, 2=import, 3=tryimport, 4=recover
5=error).
</DL>

<P>
<P>


<B>vdev_guid</B>

<DL COMPACT><DT><DD>
The GUID of the vdev in question (the vdev failing or operated upon with
<B>zpool clear</B> etc).
</DL>

<P>
<P>


<B>vdev_type</B>

<DL COMPACT><DT><DD>
Type of vdev - <B>disk</B>, <B>file</B>, <B>mirror</B> etc. See
<B><A HREF="../man8/zpool.8.html">zpool</A></B>(8)

under <B>Virtual Devices</B> for more information on possible values.
</DL>

<P>
<P>


<B>vdev_path</B>

<DL COMPACT><DT><DD>
Full path of the vdev, including any <I>-partX</I>.
</DL>

<P>
<P>


<B>vdev_devid</B>

<DL COMPACT><DT><DD>
ID of vdev (if any).
</DL>

<P>
<P>


<B>vdev_fru</B>

<DL COMPACT><DT><DD>
Physical FRU location.
</DL>

<P>
<P>


<B>vdev_state</B>

<DL COMPACT><DT><DD>
State of vdev (0=uninitialized, 1=closed, 2=offline, 3=removed, 4=failed to open, 5=faulted, 6=degraded, 7=healthy).
</DL>

<P>
<P>


<B>vdev_ashift</B>

<DL COMPACT><DT><DD>
The ashift value of the vdev.
</DL>

<P>
<P>


<B>vdev_complete_ts</B>

<DL COMPACT><DT><DD>
The time the last I/O completed for the specified vdev.
</DL>

<P>
<P>


<B>vdev_delta_ts</B>

<DL COMPACT><DT><DD>
The time since the last I/O completed for the specified vdev.
</DL>

<P>
<P>


<B>vdev_spare_paths</B>

<DL COMPACT><DT><DD>
List of spares, including full path and any <I>-partX</I>.
</DL>

<P>
<P>


<B>vdev_spare_guids</B>

<DL COMPACT><DT><DD>
GUID(s) of spares.
</DL>

<P>
<P>


<B>vdev_read_errors</B>

<DL COMPACT><DT><DD>
How many read errors that have been detected on the vdev.
</DL>

<P>
<P>


<B>vdev_write_errors</B>

<DL COMPACT><DT><DD>
How many write errors that have been detected on the vdev.
</DL>

<P>
<P>


<B>vdev_cksum_errors</B>

<DL COMPACT><DT><DD>
How many checkum errors that have been detected on the vdev.
</DL>

<P>
<P>


<B>parent_guid</B>

<DL COMPACT><DT><DD>
GUID of the vdev parent.
</DL>

<P>
<P>


<B>parent_type</B>

<DL COMPACT><DT><DD>
Type of parent. See <B>vdev_type</B>.
</DL>

<P>
<P>


<B>parent_path</B>

<DL COMPACT><DT><DD>
Path of the vdev parent (if any).
</DL>

<P>
<P>


<B>parent_devid</B>

<DL COMPACT><DT><DD>
ID of the vdev parent (if any).
</DL>

<P>
<P>


<B>zio_objset</B>

<DL COMPACT><DT><DD>
The object set number for a given I/O.
</DL>

<P>
<P>


<B>zio_object</B>

<DL COMPACT><DT><DD>
The object number for a given I/O.
</DL>

<P>
<P>


<B>zio_level</B>

<DL COMPACT><DT><DD>
The indirect level for the block. Level 0 is the lowest level and includes
data blocks. Values &gt; 0 indicate metadata blocks at the appropriate level.
</DL>

<P>
<P>


<B>zio_blkid</B>

<DL COMPACT><DT><DD>
The block ID for a given I/O.
</DL>

<P>
<P>


<B>zio_err</B>

<DL COMPACT><DT><DD>
The errno for a failure when handling a given I/O. The errno is compatible
with <B><A HREF="../man3/errno.3.html">errno</A></B>(3) with the value for EBADE (0x34) used to indicate ZFS
checksum error.
</DL>

<P>
<P>


<B>zio_offset</B>

<DL COMPACT><DT><DD>
The offset in bytes of where to write the I/O for the specified vdev.
</DL>

<P>
<P>


<B>zio_size</B>

<DL COMPACT><DT><DD>
The size in bytes of the I/O.
</DL>

<P>
<P>


<B>zio_flags</B>

<DL COMPACT><DT><DD>
The current flags describing how the I/O should be handled.  See the
<B>I/O FLAGS</B> section for the full list of I/O flags.
</DL>

<P>
<P>


<B>zio_stage</B>

<DL COMPACT><DT><DD>
The current stage of the I/O in the pipeline.  See the <B>I/O STAGES</B>
section for a full list of all the I/O stages.
</DL>

<P>
<P>


<B>zio_pipeline</B>

<DL COMPACT><DT><DD>
The valid pipeline stages for the I/O.  See the <B>I/O STAGES</B> section for a
full list of all the I/O stages.
</DL>

<P>
<P>


<B>zio_delay</B>

<DL COMPACT><DT><DD>
The time elapsed (in nanoseconds) waiting for the block layer to complete the
I/O.  Unlike <B>zio_delta</B> this does not include any vdev queuing time and is
therefore solely a measure of the block layer performance.
</DL>

<P>
<P>


<B>zio_timestamp</B>

<DL COMPACT><DT><DD>
The time when a given I/O was submitted.
</DL>

<P>
<P>


<B>zio_delta</B>

<DL COMPACT><DT><DD>
The time required to service a given I/O.
</DL>

<P>
<P>


<B>prev_state</B>

<DL COMPACT><DT><DD>
The previous state of the vdev.
</DL>

<P>
<P>


<B>cksum_expected</B>

<DL COMPACT><DT><DD>
The expected checksum value for the block.
</DL>

<P>
<P>


<B>cksum_actual</B>

<DL COMPACT><DT><DD>
The actual checksum value for an errant block.
</DL>

<P>
<P>


<B>cksum_algorithm</B>

<DL COMPACT><DT><DD>
Checksum algorithm used. See <B><A HREF="../man8/zfs.8.html">zfs</A></B>(8) for more information on checksum
algorithms available.
</DL>

<P>
<P>


<B>cksum_byteswap</B>

<DL COMPACT><DT><DD>
Whether or not the data is byteswapped.
</DL>

<P>
<P>


<B>bad_ranges</B>

<DL COMPACT><DT><DD>
[start, end) pairs of corruption offsets. Offsets are always aligned on a
64-bit boundary, and can include some gaps of non-corruption.
(See <B>bad_ranges_min_gap</B>)
</DL>

<P>
<P>


<B>bad_ranges_min_gap</B>

<DL COMPACT><DT><DD>
In order to bound the size of the <B>bad_ranges</B> array, gaps of non-corruption
less than or equal to <B>bad_ranges_min_gap</B> bytes have been merged with
adjacent corruption. Always at least 8 bytes, since corruption is detected
on a 64-bit word basis.
</DL>

<P>
<P>


<B>bad_range_sets</B>

<DL COMPACT><DT><DD>
This array has one element per range in <B>bad_ranges</B>. Each element contains
the count of bits in that range which were clear in the good data and set
in the bad data.
</DL>

<P>
<P>


<B>bad_range_clears</B>

<DL COMPACT><DT><DD>
This array has one element per range in <B>bad_ranges</B>. Each element contains
the count of bits for that range which were set in the good data and clear in
the bad data.
</DL>

<P>
<P>


<B>bad_set_bits</B>

<DL COMPACT><DT><DD>
If this field exists, it is an array of: (bad data &amp; ~(good data)); that is,
the bits set in the bad data which are cleared in the good data. Each element
corresponds a byte whose offset is in a range in <B>bad_ranges</B>, and the
array is ordered by offset. Thus, the first element is the first byte in the
first <B>bad_ranges</B> range, and the last element is the last byte in the last
<B>bad_ranges</B> range.
</DL>

<P>
<P>


<B>bad_cleared_bits</B>

<DL COMPACT><DT><DD>
Like <B>bad_set_bits</B>, but contains: (good data &amp; ~(bad data)); that is,
the bits set in the good data which are cleared in the bad data.
</DL>

<P>
<P>


<B>bad_set_histogram</B>

<DL COMPACT><DT><DD>
If this field exists, it is an array of counters. Each entry counts bits set
in a particular bit of a big-endian uint64 type. The first entry counts bits
set in the high-order bit of the first byte, the 9th byte, etc, and the last
entry counts bits set of the low-order bit of the 8th byte, the 16th byte, etc.
This information is useful for observing a stuck bit in a parallel data path,
such as IDE or parallel SCSI.
</DL>

<P>
<P>


<B>bad_cleared_histogram</B>

<DL COMPACT><DT><DD>
If this field exists, it is an array of counters. Each entry counts bit clears
in a particular bit of a big-endian uint64 type. The first entry counts bits
clears of the the high-order bit of the first byte, the 9th byte, etc, and the
last entry counts clears of the low-order bit of the 8th byte, the 16th byte,
etc. This information is useful for observing a stuck bit in a parallel data
path, such as IDE or parallel SCSI.
</DL>

<P>
<A NAME="lbAF">&nbsp;</A>
<H3>I/O STAGES</H3>

<P>
<P>

The ZFS I/O pipeline is comprised of various stages which are defined
below.  The individual stages are used to construct these basic I/O
operations: Read, Write, Free, Claim, and Ioctl.  These stages may be
set on an event to describe the life cycle of a given I/O.
<P>
<TABLE>
<TR VALIGN=top><TD>Stage</TD><TD>Bit Mask</TD><TD>Operations<BR></TD></TR>
<TR VALIGN=top><TD><HR></TD><TD><HR></TD><TD><HR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_OPEN</TD><TD>0x00000001</TD><TD>RWFCI<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_READ_BP_INIT</TD><TD>0x00000002</TD><TD>R----<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_WRITE_BP_INIT</TD><TD>0x00000004</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_FREE_BP_INIT</TD><TD>0x00000008</TD><TD>--F--<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_ISSUE_ASYNC</TD><TD>0x00000010</TD><TD>RWF--<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_WRITE_COMPRESS</TD><TD>0x00000020</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_ENCRYPT</TD><TD>0x00000040</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_CHECKSUM_GENERATE</TD><TD>0x00000080</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_NOP_WRITE</TD><TD>0x00000100</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DDT_READ_START</TD><TD>0x00000200</TD><TD>R----<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DDT_READ_DONE</TD><TD>0x00000400</TD><TD>R----<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DDT_WRITE</TD><TD>0x00000800</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DDT_FREE</TD><TD>0x00001000</TD><TD>--F--<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_GANG_ASSEMBLE</TD><TD>0x00002000</TD><TD>RWFC-<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_GANG_ISSUE</TD><TD>0x00004000</TD><TD>RWFC-<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DVA_THROTTLE</TD><TD>0x00008000</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DVA_ALLOCATE</TD><TD>0x00010000</TD><TD>-W---<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DVA_FREE</TD><TD>0x00020000</TD><TD>--F--<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DVA_CLAIM</TD><TD>0x00040000</TD><TD>---C-<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_READY</TD><TD>0x00080000</TD><TD>RWFCI<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_VDEV_IO_START</TD><TD>0x00100000</TD><TD>RW--I<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_VDEV_IO_DONE</TD><TD>0x00200000</TD><TD>RW--I<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_VDEV_IO_ASSESS</TD><TD>0x00400000</TD><TD>RW--I<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_CHECKSUM_VERIFY</TD><TD>0x00800000</TD><TD>R----<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_STAGE_DONE</TD><TD>0x01000000</TD><TD>RWFCI<BR></TD></TR>
</TABLE>

<P>
<A NAME="lbAG">&nbsp;</A>
<H3>I/O FLAGS</H3>

<P>
<P>

Every I/O in the pipeline contains a set of flags which describe its
function and are used to govern its behavior.  These flags will be set
in an event as an <B>zio_flags</B> payload entry.
<P>
<TABLE>
<TR VALIGN=top><TD>Flag</TD><TD>Bit Mask<BR></TD></TR>
<TR VALIGN=top><TD><HR></TD><TD><HR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DONT_AGGREGATE</TD><TD>0x00000001<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_IO_REPAIR</TD><TD>0x00000002<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_SELF_HEAL</TD><TD>0x00000004<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_RESILVER</TD><TD>0x00000008<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_SCRUB</TD><TD>0x00000010<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_SCAN_THREAD</TD><TD>0x00000020<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_PHYSICAL</TD><TD>0x00000040<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_CANFAIL</TD><TD>0x00000080<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_SPECULATIVE</TD><TD>0x00000100<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_CONFIG_WRITER</TD><TD>0x00000200<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DONT_RETRY</TD><TD>0x00000400<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DONT_CACHE</TD><TD>0x00000800<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_NODATA</TD><TD>0x00001000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_INDUCE_DAMAGE</TD><TD>0x00002000<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_IO_ALLOCATING</TD><TD>0x00004000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_IO_RETRY</TD><TD>0x00008000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_PROBE</TD><TD>0x00010000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_TRYHARD</TD><TD>0x00020000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_OPTIONAL</TD><TD>0x00040000<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DONT_QUEUE</TD><TD>0x00080000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DONT_PROPAGATE</TD><TD>0x00100000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_IO_BYPASS</TD><TD>0x00200000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_IO_REWRITE</TD><TD>0x00400000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_RAW_COMPRESS</TD><TD>0x00800000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_RAW_ENCRYPT</TD><TD>0x01000000<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_GANG_CHILD</TD><TD>0x02000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DDT_CHILD</TD><TD>0x04000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_GODFATHER</TD><TD>0x08000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_NOPWRITE</TD><TD>0x10000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_REEXECUTED</TD><TD>0x20000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_DELEGATED</TD><TD>0x40000000<BR></TD></TR>
<TR VALIGN=top><TD>ZIO_FLAG_FASTWRITE</TD><TD>0x80000000<BR></TD></TR>
</TABLE>

<P>

</BODY>
</HTML>
